---
title: "Calculating Measures of Diversity"
author: "Thomas Behrens"
date: "07/11/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setting Parameters

Some parameters need to be set manually, including positional information on the inversion and the locally adapted alleles. Here we also set the parameters for the sliding window. Also automatically extract some information found in the directory name.

```{r message=FALSE}
# determine whether on cluster or local
on_cluster <- Sys.info()['sysname']=='Linux'

if(on_cluster){
  # first argument is directory name, second is generation time point
  args = commandArgs(trailingOnly=TRUE)
}else{
  setwd("C:/Users/tbehr/Desktop/Thesis")
  }

library(ggplot2)
library(gridExtra)
library(reshape2)
library(tidyr)

#-----------------------------------------------------------
# PARAMETERS
#-----------------------------------------------------------

GENOME_LENGTH <- 22000
FIXED_MUTATION_POS1 <- 8000
FIXED_MUTATION_POS2 <- 12000
INV_START <- 6000
INV_END <- 16000  # this value should NOT be the '-1' value that the SLiM script uses. This script does that correction later
WINDOW_SPACING <- 200
WINDOW_SIZE <- 100   # NOTE: window size is added on each side (so the full size is more like twice this value)
N_TILES <- 200    # number of tiles along each axis of the correlation heatmap

if(on_cluster){
  PATH <- paste("Outputs", args[1], args[2], sep="/")
  simtype <- strsplit(args[1], split='_')[[1]][1]
  generation <- as.integer(args[2])
}else{
  PATH <- "Outputs/inversionLAA_2pop_s0.01_m0.001_mu1e-6/14000"
  simtype <- strsplit(strsplit(PATH, split='/')[[1]][2], split='_')[[1]][1]
  generation <- as.integer(strsplit(PATH, split='/')[[1]][3])
}

# record presence or absence of inversion and locally adapted alleles
INVERSION_PRESENT <- ifelse(simtype=='adaptiveInversion' || simtype=='inversionLAA' ,TRUE, FALSE)
LAA_PRESENT <- ifelse(simtype=='locallyAdapted' || simtype=='inversionLAA' ,TRUE, FALSE)

```

## Functions

**get_ms_data** and **get_positions** are used to extract the binary matrix and absolute positions from the raw MS file.

```{r message=FALSE}
get_ms_data <- function(filename){
  # read in ms file (ignoring first 3 lines), and as strings
  ms_binary_conjoined <- read.table(filename, skip = 3, colClasses = 'character')
  # split each line into its elements as separate columns
  ms_binary <- apply(ms_binary_conjoined, 1, function(x) as.integer(unlist(strsplit(x,""))))
  # flip axes so it matches with original file
  ms_binary <- t(ms_binary)
  return(ms_binary)
}

get_positions <- function(filename){
  # read in third line of text file containing relative positions
  positions_row <- readLines(filename)[3]
  relative_positions <- as.numeric(unlist(strsplit(positions_row, " "))[-1])
  abs_positions <- relative_positions * (GENOME_LENGTH-1)
  #return(abs_positions)
  return(round(abs_positions))
}
```

### Sliding Window

With combined columns of a given statistic at each position in a particular sample, this function will generalize that data into a constant number of windows (for given window parameters).  
The centers of these windows are equally spaced, and include both position 0 and the final position (such that half of the first and last windows will extend beyond the ends of the chromosome).  
For each of these centers, all values for positions within the range of the window size are averaged uniformly, so each window has a single summary statistic (or NA if no positions fall in the window)  

```{r message=FALSE}
# takes a dataframe where first column is position and second column is the value
calc_sliding_window <- function(posValData, totalLength, windowSize, pointSpacing){
  centers <- seq(0, totalLength, by=pointSpacing)
  output <- data.frame(position=centers, average=NA)
  for(i in 1:length(centers)){
    correspondingValues <- posValData[2][posValData[1] > centers[i]-windowSize & posValData[1] <= centers[i]+windowSize]
    output[i, 2] <- mean(correspondingValues)
  }
  return(output)
}
```

### Single Nucleotide Diversity Calculation

Because nucleotide diversity is calculated across a sequence rather than at each position separately, the function below will already create the sliding windows.  
It begins by calculating the window centers, which include the first and last positions of the chromosome, to then loop over. At each of these centers, it is determined which positions fall within its window, and these rows and then extracted into the *ms_in_seq* matrix.  
So long as there is at least one column in a window, I used the **dist()** function which will return a dist object which contains the pairwise distances between all rows. The Manhattan method ensures that this distance is computed in a way that doesn't use "diagonal distance". The sum of this matrix gives the total number of differences between all pairwise comparisons, which is doubled to include values both above and below the diagonal.  
I use *adjusted_seq_len* because the sequences at the first and last positions will be roughly half as large as all other sequences given that they will extend outside the range of the genome. I wrote it in a way that should be flexible for different window sizes and spacing.  
Finally, the nucleotide diversity at a given center is calculated as the $\frac{\sum{p_{ij}} / |p_{ij}|}{seqlength}$ in which p~ij~ is the number of pairwise comparisons between sequence i and j, and |p~ij~| is the total number of pairwise comparisons.  

```{r message=FALSE}
# calculating nucleotide diversity. Returns dataframe with nucdiv at spaced positions  --> NOTE: edited to remove marker mutations
# NOTE: seqLen is only really HALF the window size (adds seqLen in both directions of a point)
calc_nuc_div <- function(msdata, positions, totalLength, seqLen=200, centerSpacing=100){
  centers <- seq(0, totalLength, by=centerSpacing)
  # prepare storage for nucleotide diversity at each center position
  output <- data.frame(position=centers, nuc_div=NA)
  num_of_seq <- dim(msdata)[1]
  for(seqCenter in centers){
    positions_in_sequence <- which(   # select positions within window
      positions > seqCenter-seqLen & positions <= seqCenter+seqLen & !(positions %in% c(INV_START, INV_END-1))
    )  
    ms_in_seq <- as.matrix(msdata[,positions_in_sequence])
    # only do the calculations if more than one position
    if(dim(ms_in_seq)[2] > 0){
      # dist calculates distance between every combination of rows in a matrix. Manhattan method avoids "diagonal" distance
      distances_all <- dist(ms_in_seq, method='manhattan')
      # use this to adjust the sequence length when the window exceeds the range of the genome
      adjusted_seq_len <- sum((c((seqCenter-seqLen):(seqCenter+seqLen)))>=0 & (c((seqCenter-seqLen):(seqCenter+seqLen)))<=totalLength)
      # at a given position (center), nucdiv is the average number of differences divided by the length of the sequence window
      # Note: average number of differences is the total number of pairwise differences / the number of pairwise difference nChoosek
      
      
      # output[output$position==seqCenter,2] <- (sum(distances_all) / choose(num_of_seq,2)) / adjusted_seq_len
      # here using 2x sum of distances_all to account for both parts of the pairwise comparison matrix (above and below the diagonal)
      output[output$position==seqCenter,2] <- (2*sum(distances_all) / (num_of_seq^2)) / adjusted_seq_len
    }
  }
  return(output)
}
```

## Looping over Files

The primary loop in my script loops over each file one at a time, and calculates and stores the given measures and tags. This is to avoid storing the binary matrix for each file. The code below is a subset of that loop that only extracts the tags from the filenames.

``` {r message=TRUE}
# read in files (values: selection coefficient, migration rate, replicate #)
files <- list.files(path=PATH, pattern="*.txt", full.names=F, recursive=FALSE)
n_files <- length(files)
# pre-calculate window centers' positions
window_centers <- seq(0, GENOME_LENGTH, by=WINDOW_SPACING)
tags_index <- data.frame(population=character(n_files), sel_coef=numeric(n_files), migration=numeric(n_files), 
                         repl=integer(n_files), stringsAsFactors=F)

for(i in 1:n_files){
  filepath <- paste0(PATH, "/", files[i])
  # extract metadata from filename
  tags <- strsplit(files[i], split='_')[[1]]
  tags_index[i,] <- list(tags[2], as.numeric(tags[3]), as.numeric(tags[4]), as.integer(tags[5]))
}
```




## Result



```{r plotting, echo=FALSE}

```

